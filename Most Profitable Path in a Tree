class Solution {
    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {
        int n = amount.length;
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        for (int[] e : edges) {
            graph.get(e[0]).add(e[1]);
            graph.get(e[1]).add(e[0]);
        }

        int[] bobTime = new int[n];
        Arrays.fill(bobTime, Integer.MAX_VALUE);
        findBobPath(graph, bob, -1, 0, bobTime);

        return dfsAlice(graph, 0, -1, 0, bobTime, amount, 0);
    }

    private boolean findBobPath(List<List<Integer>> graph, int node, int parent, int time, int[] bobTime) {
        bobTime[node] = time;
        if (node == 0) return true; 
        for (int nei : graph.get(node)) {
            if (nei == parent) continue;
            if (findBobPath(graph, nei, node, time + 1, bobTime)) return true;
        }
        bobTime[node] = Integer.MAX_VALUE; 
        return false;
    }

    private int dfsAlice(List<List<Integer>> graph, int node, int parent, int time,
                         int[] bobTime, int[] amount, int income) {
       
        if (time < bobTime[node]) {
            income += amount[node]; 
        } else if (time == bobTime[node]) {
            income += amount[node] / 2;
        } 

        if (graph.get(node).size() == 1 && node != 0) {
            return income;
        }

        int best = Integer.MIN_VALUE;
        for (int nei : graph.get(node)) {
            if (nei == parent) continue;
            best = Math.max(best, dfsAlice(graph, nei, node, time + 1, bobTime, amount, income));
        }
        return best;
    }
}
  