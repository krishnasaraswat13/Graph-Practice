//Articulation point in a graph is a vertex which when removed along with its associated edges increases the number of connected components in the graph.
//Nodes on which removal the graph breaks into multiple components

//in bridges we were checking for edges but here we are checking for nodes

//there is a slight modification in the bridge code where the checking condition is changed in which we compare low[it]>=tim[node] instead of low[it]>tim[node] because in this case if low[it]==tim[node] then also it means that there is no other way to reach the ancestor nodes except through this node so this node is an articulation point
//Also we have to take care of the root node separately because for root node there is no parent so if it has two or more children then it is an articulation point so in checking codition will be low[it]>=tim[node] && parent!=-1 for non root nodes and for root node we will check if it has two or more children
//Also we ned to take care that if the parent is-1 then we should know that it is root node so we will maintain a count of children for root node cuz if this node is removed then all its children will be disconnected from each other bu if the child is only one then its removal will not disconnect any other node from each other so we need to maintain a count of children for root node
//we are ttaking care of visited array to avoid revisiting nodes  to only check unvisited nodes because even if a node is visited we have to check for back edges to update the low values


class Solution {
    // Function to return Breadth First Traversal of given graph.
    static int timer=1;
    public void dfs(int node,int[] tim,int[] low,int[] vis,int[] mark,int parent,ArrayList<ArrayList<Integer>> adj){
        vis[node]=1;
        tim[node]=low[node]=timer;
        timer++;
        int child=0;
        
        for(Integer it:adj.get(node)){
            if(it==parent) continue;
            
            if(vis[it]==0){
                dfs(it,tim,low,vis,mark,node,adj);
                low[node]=Math.min(low[node],low[it]);
                if(low[it]>=tim[node] && parent!=-1){  //there there is change than bridges wali that here we are also taking it as equal bcz if it can reach that node tk only then also it will not reach above elements ans we are neglecting the first node(parent condition) bcz we will check it later to know if they have more then one child the only it will consider as articulation point
                    mark[node]=1;
                }
                child++;
            }
            else{
                low[node]=Math.min(low[node],tim[it]); //here also we are not comparing low to low but low to tim
            }
        }
        if(child>1 && parent==-1){   //this is case for starting node
            mark[node]=1;
        }
    }
    public ArrayList<Integer> articulationPoints(int n,
                                                 ArrayList<ArrayList<Integer>> adj) {
        // Code here
        int vis[]=new int[n];
        int tim[]=new int[n];
        int low[]=new int[n];
        int mark[]=new int[n];//this we are using so that if an node is declared as articulation point then if we add directly then may be repeated addition occur..so we mark that node as 1 and later we add on that
       for(int i=0;i<n;i++){
           if(vis[i]==0){
             dfs(i,tim,low,vis,mark,-1,adj);
           }
       }
        ArrayList<Integer> ans=new ArrayList<>();
        for(int i=0;i<n;i++){
            if(mark[i]==1){
                ans.add(i);
            }
        }
        if(ans.size()==0){
            ans.add(-1);
        }
        return ans;
    }
}