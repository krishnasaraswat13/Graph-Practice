// Kruskal Algo -> This algorithm is used to find the minimum spanning tree of a connected, undirected graph.
// It works by sorting all the edges in non-decreasing order of their weight and adding them one by one to the MST,
// ensuring that no cycles are formed using the Union-Find data structure.
//it uses concept of disjoint set union(DSU) to keep track of connected components.

import java.util.*;

class Solution {
    // Edge class to store graph edges
    static class Edge implements Comparable<Edge> {
        int src, dest, weight;
        Edge(int s, int d, int w) {
            this.src = s;
            this.dest = d;
            this.weight = w;
        }
        public int compareTo(Edge other) {
            return this.weight - other.weight;
        }
    }

    // Disjoint Set Union (DSU) for cycle detection
    static class DisjointSet {
        int[] parent, size;
        public DisjointSet(int n) {
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        public int findUPar(int node) {
            if (node == parent[node]) return node;
            return parent[node] = findUPar(parent[node]); // Path compression
        }

        public void unionBySize(int u, int v) {
            int rootU = findUPar(u);
            int rootV = findUPar(v);
            if (rootU != rootV) {
                if (size[rootU] < size[rootV]) {
                    parent[rootU] = rootV;
                    size[rootV] += size[rootU];
                } else {
                    parent[rootV] = rootU;
                    size[rootU] += size[rootV];
                }
            }
        }
    }

    public int spanningTree(int V, int[][] edgesInput) {
        List<Edge> edges = new ArrayList<>();
        int E=edgesInput.length;
        // 1. Convert input array to Edge objects
        for (int i = 0; i <E ; i++) {
            edges.add(new Edge(edgesInput[i][0], edgesInput[i][1], edgesInput[i][2]));
        }

        // 2. Sort edges by weight: O(E log E)
        Collections.sort(edges);

        DisjointSet ds = new DisjointSet(V);
        int mstWeight = 0;
        int edgesCount = 0;

        // 3. Process edges: O(E * Î±(V))
        for (Edge edge : edges) {
            if (ds.findUPar(edge.src) != ds.findUPar(edge.dest)) {
                mstWeight += edge.weight;
                ds.unionBySize(edge.src, edge.dest);
                edgesCount++;
                
                // Optimization: MST always has V-1 edges
                if (edgesCount == V - 1) break;
            }
        }

        return mstWeight;
    }

}